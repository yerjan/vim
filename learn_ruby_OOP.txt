Class:
	class Animal
    # instance variables cannot be accessed directly! Only through methods.
    # this is regular getter setter for noise
    def noise=(noise)
      @noise = noise
    end
    
    def noise(noise)
      @noise
    end
    
    # this getter setter is equivalent with "attr_accessor :noise"
	end

  # create an instance 
  
  animal = Animal.new
  animal.noise = "Moo!"
  puts animal.noise
  
attr_reader (getter), attr_writer (setter), attr_accessor (both)

Initialize Method:
  # this is a class constructor method
  
  def initialize(noise="Moo!", legs=4, arms=0)
    @noise = noise
    @legs = legs
    @arms = arms
    puts "initialized!"
  end

Class methods:

  def self.all_species
    ['cat', 'cow', 'dog', 'pig']
  end
  
  def self.create_with_attributes(noise, color)
    animal = self.new(noise)
    animal.color = color
    return animal
  end
  
  class attributes also require getter setter method meaning direct access is restricted.

Inheritance:
  class Cow < Animal
    # by redefining the class we can simply override parent class
    
    def color
      "The cow's color is #{@color}."
    end
  end
  
  
Modules:
  # Module is like wrapper to classes.
  # Or it can be assumed as if Namespaces
  
  for example:
  
  module Romantic
    class Date
      ...
    end
  end
  
  this Date class differs from Ruby standart library Date by Module Romantic.
  
  Modules cannot be instantiated and to use:
    dinner::Romantic::Date.new
    
Mix-Ins:
  # mixins is like multi inheritance.
  # we define module and include it in class, so that class acts like module
  # because class only allows single inheritance.
  # this way class can inherit from single class but include some general module at the same time

  module ContactInfo
    def fullname
    end
    
    def compute_age
    end
  end
    
  class Person
    include ContactInfo
  end
    
  class Teacher < Person
    # now Teacher includes Module and inherited from Person at the same time
  end
    
Load, Require and Include:
  load:
    load is what loads file when it is separately saved in different path etc.
    # loads a source file every time it is called

  require:
    require keeps track of previous load; therefore, it will not load twice!
    require is like "load if not loaded"
  
  include:
    include has nothing to do with file but includes module
    
Enumerable as a mixin:
  Enumerable is what Collection type class should always have like:
    - sort
    - compare
    - for each traverse (should be defined!)
  
  # maybe including some standart syntax sugar and features.
  # might not directly used at the beginning.
  
  class ToDoList
    include Enumerable
    
    def initialize
      @items = []
    end
    
    def each
      @items.each {|item| yield item}
    end
  end
    
    
    
    
    
    
    
    
    
    
    
    
    
    